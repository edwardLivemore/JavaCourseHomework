## 毕业总结
### 1.JVM
#### 1.1 字节码
##### 分类: 
栈操作、程序流程控制、对象操作、算术运算及类型转换

#### 1.2 虚拟机内存
##### 分类:
栈: 存放方法参数、方法内部变量等, 通过-XSS调整栈深度

堆: 存放实例、共有变量等, 通过-Xmx调整最大堆内存，-Xms调整初始堆内存大小，一般两者一致, 其中堆内存又分为年轻代和老年代, 
可以通过-Xmn调整年轻代区的内存大小

非堆: JDK1.8后为元数据区(MetaSpace), 主要由方法区和方法区内的常量池组成

堆外内存: 直接内存，通过设置-XX参数调整最大的堆外内存
#### 1.3 GC
##### 分类:
 
串行GC: CPU利用率高，STW时间长，单线程

并行GC: 追求吞吐量、STW时间较串行GC更短、多线程，可通过-XX:ParallelGCThreads参数设置GC线程数

CMS: 对于老年代只标记清理不整理内存碎片、并发清理时不影响业务线程，STW时间短

G1: 将堆内存切分为2048个小块, 每一个小块都可以是年轻代和老年代，启发式回收，STW时间短

ZGC: 支持超大堆内存(几TB), STW时间<10ms, 吞吐量相较于G1下降约15%

##### 常用GC组合
1. Serial + Serial Old 单线程，低延迟

2. ParNew + CNS 多线程, 低延迟

3. ParallelScavage + ParallelScavageOld 多线程, 高吞吐量

##### JVM调优
1. 分配速率(修改young区大小)
2. 提升速率(修改晋升速率)


### 2.NIO
#### 2.1 IO模型
BIO: 阻塞IO, 应用程序需要等待内核准备数据

NIO: 非阻塞IO，应用程序无需等待，内核立刻返回, 然后不断主动轮询内核数据是否准备好

IO复用: 各司其职，有专有的线程维护网络连接

信号驱动: 无需主动轮询，数据准备好后主动发送信号通知应用程序

异步IO: 回调消息, 需操作系统支持

#### 2.2 Netty基本概念
Channel: 连接通道，负责读取/写入IO操作

ChannelFuture: 接收回调方法

Event&Handler: 事件和处理器关联到入站出站数据流

Encoder&Decoder: 序列化和反序列化

ChannelPipline: 事件处理器链

#### 2.3 Reactor模型
IO处理与业务处理分离, MainReactor(BossGroup) + SubReactor(WorkerGroup) 相结合

### 3.多线程
#### 3.1 多线程的基本问题
由于线程各自读写共同变量引起的并发问题: 原子性、可见性、有序性

#### 3.2 Java多线程的启动方式
实现Runnable接口

实现Callable接口

线程池(newSingleThreadExecutor、newFixedTheadPool、newChannelThreadPool、newScheduledThreadPool)

实现Future接口

CompletableFuture

CountDownLatch

CyclicBarrier

#### 3.3 Java线程安全的方法
final

volatile

synchronized (wait -> notify/notify all)

Atomic原子类

Lock(重入锁、读写锁 await -> signal/signal all)

ThreadLocal

信号量(Semaphore)

CopyOnWriteList、ConcurrentHashMap等

#### 3.4 Lock类与synchronized区别
可中断、可超时、Lock类在await时释放锁资源、支持公平锁

### 4.Spring
引入Spring意味着引入协作研发的模式，将业务水平分割成模块相关，竖直分割成业务流程关联

#### 4.1 六大模块
Core(Bean/Context, AOP)、Testing、DataAccess、SpringMVC/Webflux、Integration(remoting、JMS、WS)、Language(Kotlin/Groovy)

#### 4.2 核心功能
控制反转: 通过代码中@Bean注解声明或Xml文件中声明Bean, 将Bean由Spring容器统一进行管理

AOP: 接口类型(JDK代理)、非接口类型(CGlib代理)

#### 4.3 SpringBoot
简化Spring配置，使用注解取代繁琐的Xml配置，使用注解开启各个功能组件

#### 4.4 SpringBoot两大核心
自动化配置(@Configuration, @EnableXXXX, @ConditionOnXXXX)

Spring-boot-starter 脚手架

#### 4.5 SpringBoot自动装配
1. 通过@EnableAutoConfiguration开启自动装配

2. 使用@Configuration注解自定义配置类

3. 使用@Import导入自定义配置类

4. 在src/main/resources/META-INF/spring.factories文件中添加org.springframework.boot.auto.configuration=com.xxx.自定义配置类

5. 使用@ConditionalOnXXXX 注解条件化配置

#### 4.6 ORM
对象映射管理, Spring中的ORM主要有:

Hibernate: 简单场景下不用写SQL但对DBA不友好

MyBatis: 原生SQL，对DBA友好，但配置较繁琐

### 5.MYSQL
#### 5.1 SQL语言分类
数据查询语言: SELECT、WHERE、GROUP BY、ORDER BY等

数据操作语言: INSERT、UPDATE、DELETE等

事务控制语言: COMMIT、ROLLBACK等

数据控制语言: GRANT、REVOKE等

数据定义语言: CREATE、DROP、ALTER等

指针控制语言: DECLARE、FETCH INTO等

#### 5.2 MYSQL结构
连接池、SQL接口、解析器、优化器、缓存、引擎层、存储文件

#### 5.3 MYSQL执行流程
客户端连接服务器, 用户连接状态权限校验, 查询缓存(若命中则直接返回), 执行SQL解析, 执行SQL优化, 生成执行计划, 查询执行引擎, 写入RedoLog以及BinLog, 返回结果

#### 5.4 MYSQL中的SQL执行顺序
from -> on -> join -> where -> group by -> having + 聚合函数 -> select -> order by -> limit

#### 5.5 InnoDB索引
底层由B+树实现, 叶子结点为数据, 其他节点为索引, 且叶子节点之间由双向链表连接, 相较于B树更适合范围查询

#### 5.6 MYSQL优化
1. 选择合适的引擎

2. 库表命名

3. 合理拆分宽表

4. 选择恰当的数据类型(char与varchar的选择、text及blob/clob的使用、文件及图片的存储、时间日期的存储、数据精度等)

5. 是否使用外键或触发器

6. 唯一约束和索引的关系(唯一约束自动创建索引)

7. 适当使用冗余字段

8. 不建议使用存储过程、自定义函数等处理业务逻辑

9. 自增主键的使用

10. 在线DDL操作

11. 建议使用逻辑删除

12. 建议每张表都增加create_time 和 update_time

13. 数据库碎片问题

14. 快速导入导出数据，备份数据

15. 大批量数据写入优化(PreparedStatement, Load Data直接导入)

16. 数据更新范围(缩小锁的范围)

17. 模糊查询(LIKE语句最左缀原则, 全文检索推荐使用Solr/ES)

18. 连接查询(选择较小的表为驱动表、避免笛卡尔积)

19. 索引失效问题(避免使用Null、Not、Not IN、函数等, or => union, 必要时使用force index)

20. 避免使用临时文件或临时表，按需求可以手动维护汇总表

#### 5.7 事务
事务模型: 原子性、一致性、隔离性、持久性

MYSQL隔离级别: 读未提交、读已提交、可重复读(默认)、串行化

MYSQL锁: 表锁、行锁、间隙锁、临键锁

#### 5.8 主键生成方案
自增长主键、Sequence、UUID、时间戳/随机数、SnowFlake

#### 5.9 MySQL集群
主从复制解决读写压力(高性能问题), 主从切换解决高可用问题
