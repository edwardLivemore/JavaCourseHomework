## 毕业项目
### 1.JVM
#### 1.1 字节码
##### 分类: 
栈操作、程序流程控制、对象操作、算术运算及类型转换

#### 1.2 虚拟机内存
##### 分类:
栈: 存放方法参数、方法内部变量等, 通过-XSS调整栈深度

堆: 存放实例、共有变量等, 通过-Xmx调整最大堆内存，-Xms调整初始堆内存大小，一般两者一致, 其中堆内存又分为年轻代和老年代, 
可以通过-Xmn调整年轻代区的内存大小

非堆: JDK1.8后为元数据区(MetaSpace), 主要由方法区和方法区内的常量池组成

堆外内存: 直接内存，通过设置-XX参数调整最大的堆外内存
#### 1.3 GC
##### 分类:
 
串行GC: CPU利用率高，STW时间长，单线程

并行GC: 追求吞吐量、STW时间较串行GC更短、多线程，可通过-XX:ParallelGCThreads参数设置GC线程数

CMS: 对于老年代只标记清理不整理内存碎片、并发清理时不影响业务线程，STW时间短

G1: 将堆内存切分为2048个小块, 每一个小块都可以是年轻代和老年代，启发式回收，STW时间短

ZGC: 支持超大堆内存(几TB), STW时间<10ms, 吞吐量相较于G1下降约15%

##### 常用GC组合
1. Serial + Serial Old 单线程，低延迟

2. ParNew + CNS 多线程, 低延迟

3. ParallelScavage + ParallelScavageOld 多线程, 高吞吐量

##### JVM调优
1. 分配速率(修改young区大小)
2. 提升速率(修改晋升速率)


### 2.NIO
#### 2.1 IO模型
BIO: 阻塞IO, 应用程序需要等待内核准备数据

NIO: 非阻塞IO，应用程序无需等待，内核立刻返回, 然后不断主动轮询内核数据是否准备好

IO复用: 各司其职，有专有的线程维护网络连接

信号驱动: 无需主动轮询，数据准备好后主动发送信号通知应用程序

异步IO: 回调消息, 需操作系统支持

#### 2.2 Netty基本概念
Channel: 连接通道，负责读取/写入IO操作

ChannelFuture: 接收回调方法

Event&Handler: 事件和处理器关联到入站出站数据流

Encoder&Decoder: 序列化和反序列化

ChannelPipline: 事件处理器链

#### 2.3 Reactor模型
IO处理与业务处理分离, MainReactor(BossGroup) + SubReactor(WorkerGroup) 相结合

### 3.多线程
#### 3.1 多线程的基本问题
由于线程各自读写共同变量引起的并发问题: 原子性、可见性、有序性

#### 3.2 Java多线程的启动方式
实现Runnable接口

实现Callable接口

线程池(newSingleThreadExecutor、newFixedTheadPool、newChannelThreadPool、newScheduledThreadPool)

实现Future接口

CompletableFuture

CountDownLatch

CyclicBarrier

#### 3.3 Java线程安全的方法
final

volatile

synchronized (wait -> notify/notify all)

Atomic原子类

Lock(重入锁、读写锁 await -> signal/signal all)

ThreadLocal

信号量(Semaphore)

CopyOnWriteList、ConcurrentHashMap等

#### 3.4 Lock类与synchronized区别
可中断、可超时、Lock类在await时释放锁资源、支持公平锁

### 4.Spring
引入Spring意味着引入协作研发的模式，将业务水平分割成模块相关，竖直分割成业务流程关联

#### 4.1 六大模块
Core(Bean/Context, AOP)、Testing、DataAccess、SpringMVC/Webflux、Integration(remoting、JMS、WS)、Language(Kotlin/Groovy)

#### 4.2 核心功能
控制反转: 通过代码中@Bean注解声明或Xml文件中声明Bean, 将Bean由Spring容器统一进行管理

AOP: 接口类型(JDK代理)、非接口类型(CGlib代理)

#### 4.3 SpringBoot
简化Spring配置，使用注解取代繁琐的Xml配置，使用注解开启各个功能组件

#### 4.4 SpringBoot两大核心
自动化配置(@Configuration, @EnableXXXX, @ConditionOnXXXX)

Spring-boot-starter 脚手架

#### 4.5 SpringBoot自动装配
1. 通过@EnableAutoConfiguration开启自动装配

2. 使用@Configuration注解自定义配置类

3. 使用@Import导入自定义配置类

4. 在src/main/resources/META-INF/spring.factories文件中添加org.springframework.boot.auto.configuration=com.xxx.自定义配置类

5. 使用@ConditionalOnXXXX 注解条件化配置

#### 4.6 ORM
对象映射管理, Spring中的ORM主要有:

Hibernate: 简单场景下不用写SQL但对DBA不友好

MyBatis: 原生SQL，对DBA友好，但配置较繁琐

### 5.MYSQL
#### 5.1 SQL语言分类
数据查询语言: SELECT、WHERE、GROUP BY、ORDER BY等

数据操作语言: INSERT、UPDATE、DELETE等

事务控制语言: COMMIT、ROLLBACK等

数据控制语言: GRANT、REVOKE等

数据定义语言: CREATE、DROP、ALTER等

指针控制语言: DECLARE、FETCH INTO等

#### 5.2 MYSQL结构
连接池、SQL接口、解析器、优化器、缓存、引擎层、存储文件

#### 5.3 MYSQL执行流程
客户端连接服务器, 用户连接状态权限校验, 查询缓存(若命中则直接返回), 执行SQL解析, 执行SQL优化, 生成执行计划, 查询执行引擎, 写入RedoLog以及BinLog, 返回结果

#### 5.4 MYSQL中的SQL执行顺序
from -> on -> join -> where -> group by -> having + 聚合函数 -> select -> order by -> limit

#### 5.5 InnoDB索引
底层由B+树实现, 叶子结点为数据, 其他节点为索引, 且叶子节点之间由双向链表连接, 相较于B树更适合范围查询

#### 5.6 MYSQL优化
1. 选择合适的引擎

2. 库表命名

3. 合理拆分宽表

4. 选择恰当的数据类型(char与varchar的选择、text及blob/clob的使用、文件及图片的存储、时间日期的存储、数据精度等)

5. 是否使用外键或触发器

6. 唯一约束和索引的关系(唯一约束自动创建索引)

7. 适当使用冗余字段

8. 不建议使用存储过程、自定义函数等处理业务逻辑

9. 自增主键的使用

10. 在线DDL操作

11. 建议使用逻辑删除

12. 建议每张表都增加create_time 和 update_time

13. 数据库碎片问题

14. 快速导入导出数据，备份数据

15. 大批量数据写入优化(PreparedStatement, Load Data直接导入)

16. 数据更新范围(缩小锁的范围)

17. 模糊查询(LIKE语句最左缀原则, 全文检索推荐使用Solr/ES)

18. 连接查询(选择较小的表为驱动表、避免笛卡尔积)

19. 索引失效问题(避免使用Null、Not、Not IN、函数等, or => union, 必要时使用force index)

20. 避免使用临时文件或临时表，按需求可以手动维护汇总表

#### 5.7 事务
事务模型: 原子性、一致性、隔离性、持久性

MYSQL隔离级别: 读未提交、读已提交、可重复读(默认)、串行化

MYSQL锁: 表锁、行锁、间隙锁、临键锁

#### 5.8 主键生成方案
自增长主键、Sequence、UUID、时间戳/随机数、SnowFlake

#### 5.9 MySQL集群
主从复制解决读写压力(高性能问题), 主从切换解决高可用问题

### 6.分库分表
#### 6.1 垂直分库(表)
垂直分库: 将一个数据库按业务拆分成多个提供不同业务能力的数据库

垂直分表: 单表数据量过大时对单表进行拆分, 如订单表拆分成订单表、订单详情表、订单支付表、订单配送表等

垂直拆分的步骤:

1. 梳理清楚拆分的影响范围

2. 检查评估影响到的服务

3. 准备新的数据库集群复制数据

4. 修改系统配置并发布新版上线

垂直拆分的优缺点:

优点: 

1. 使单库(表)变小, 易于管理和维护

2. 对性能和容量有提升

3. 改造后数据复杂度降低

4. 可以作为微服务的改造基础

缺点:

1. 库变多，管理复杂

2. 对业务系统有较强侵入性

3. 改造过程复杂，易出故障

4. 拆分到一定程度无法继续拆分

#### 6.2 水平分表
水平拆分与业务无关，仅基于表容量拆分

水平拆分优缺点:

优点:

1. 业务侵入性小

2. 与业务无关, 可以无限拆分, 解决容量问题

3. 部分提升性能及稳定性

缺点:

1. 数据总量不变, 仅减少单表的数据量

2. 表增多，管理复杂

3. 数据迁移问题

4. 一致性问题

5. 复杂SQL的支持问题

### 7.RPC及微服务
#### 7.1 分布式事务
分类: 强一致性事务(如XA) 和 柔性事务(如TCC/AT)

|特点|本地事务|XA事务|柔性事务|
|:-----|:-----|:-----|:-----|
|业务改造|否|否|实现相关接口|
|一致性|不支持|支持|最终一致|
|隔离性|不支持|支持|业务方保证|
|并发性能|不影响|严重衰退|略微衰退|
|适合场景|业务处理不一致|短事务&低并发|长事务&高并发|

TCC需要业务实现的三段处理:

1. 准备操作Try: 完成所有业务检查，预留必须的资源

2. 确认操作Confirm: 真正执行业务逻辑，需要满足幂等性

3. 取消操作Cancel: 释放Try阶段预留的资源，需要满足幂等性

AT: 由框架托管，自动生成反向SQL语句，只适用于简单SQL场景

#### 7.2 RPC
RPC: 远程过程调用，像调用本地方法一样调用远程方法

RPC原理: 
1. 本地代理存根Stub

2. 本地序列化和反序列化

3. 网络通信

4. 远程序列化和反序列化

5. 远程服务存根Skeleton

6. 调用实际业务服务

7. 原路返回服务结果

8. 返回给本地调用方

#### 7.3 分布式服务
分布式服务特点: 服务之间直接调用，侧边(配置中心、注册中心等)增强

组件:
1. 配置中心: 负责各环境的共有配置信息(Apollo, Nacos, Zookeeper等)

2. 注册中心: 负责微服务的发现和注册(Eureka, Nacos等)

3. 网关: 负责统一的限流、路由、权限认证、监控等(Zuul, Spring Cloud Gateway, OAuth2认证中心等)

4. Feign: 负责微服务之间的调用

5. 负载均衡: 负责分担流量，分担压力(Ribbon等)

6. 熔断、限流: Hystrix等

7. 链路监控: CAT等

8. 日志监控: ELK等

9. 消息队列中间件: Kafka, RocketMQ, RabbitMQ等


负载均衡策略:

1. 随机(带权重)

2. 轮询

3. 快的多给

4. 同样的参数请求到同一个服务提供者


服务流控策略:
1. 限流: 控制内部线程数和外部调用数或数据量等

2. 服务降级: 只保留核心业务逻辑

3. 过载保护: 短时间内不提供新的业务服务

### 8.分布式缓存
#### 8.1 缓存过期策略
1. 按FIFO或LRU

2. 按固定时间

3. 按业务时间加权

#### 8.2 缓存常见问题
1. 缓存穿透: 大量并发查询不存在的KEY; 解决办法: 缓存空值的KEY, Bloom过滤, 完全以缓存为准

2. 缓存击穿: 大量并发查询某个失效的KEY; 解决办法: 对KEY的更新操作添加全局锁，完全以缓存为准

3. 缓存雪崩: 某一个时间发生大规模的缓存失效; 解决办法: 更新策略在时间上做均匀处理, 热数据尽量分散到不同的机器, 主从复制实现高可用, 熔断机制

#### 8.3 Redis数据结构
字符串、Hash、列表、集合、有序集合、位图、HyperLogLogs、GEO

#### 8.4 Redis使用场景
1. 业务数据缓存: 通用数据、实时数据、会话、token等

2. 业务数据处理: 非严格一致性要求的数据、业务数据去重、排名排行等

3. 全局一致计数: 流控计数、秒杀库存、抢红包、全局ID生成

4. 高效统计计数: id去重、UV、PV等数据

5. 发布订阅与Stream: 简单的消息队列

6. 分布式锁: 原子性、互斥、超时

#### 8.5 Redis高级功能
1. 事务: MULTI、EXEC、DISCARD

2. Lua脚本: 保持操作的原子性

3. PIPLine管道技术: 多命令组合，减少网络IO消耗

4. 备份与恢复: RDB(全量)、AOF(增量)

#### 8.6 Redis集群
1. 主从复制: 读写分离, 实现高性能

2. 哨兵机制: 监控节点、选主、通知客户端, 实现高可用


### 9.分布式消息队列
#### 9.1 MQ的作用
1. 异步通信, 减少线程等待

2. 系统解耦, 服务之间不再直接调用, 减低耦合度

3. 削峰填谷, 缓冲流量压力

4. 可靠通信, 提供多种消息模式, 服务质量、服务保障

#### 9.2 消息处理模式
1. 点对点: 对应于Queue

2. 发布订阅: 对应于Topic

#### 9.3 消息队列的分代
1. 第一代: ActiveMQ、RabbitMQ 特点: 支持各种消息协议

2. 第二代: Kafka、RocketMQ 特点: 支持消息堆积、事务等特性

3. 第三代: Apache Pulsar 特点: 支持计算节点与存储节点分离, 实现真正的分布式缓存

#### 9.4 Kafka基本概念
1. Broker: 服务器

2. Topic: 每条发布的消息都有一个类别，这个类别就是Topic

3. Partition: 每个Topic包含一个或多个Partition

4. Producer: 生产者, 负责发布消息到Broker

5. Consumer: 消费者, 从Broker中获取消息

6. ConsumerGroup: 每个消费者属于一个特定的ConsumerGroup

#### 9.5 Kafka高级特性
生产者特性:

1. 由客户端实现序列化、压缩、分区操作

2. 确认模式: ack级别从大到小, 则一致性越大，性能越小

3. 同步发送: future.get()

4. 异步发送: 默认发送模式

5. 顺序保证: max.in.flight.requests.per.connection = 1

6. 事务

消费者特性:

1. ConsumerGroup: 同一条消息只被同一个消费者组中的一个消费者消费, 且同一个消费者组内的消费者数量要小于等于分区数量

2. offset同步提交: enable.auto.commit=false, consumer.commitSync()

3. offset异步提交: enable.auto.commit=false, consumer.commitAsync()

4. offset自动提交: enable.auto.commit=true, auto.commit.internal.ms=毫秒数

5. offset seek: 读取制定的offset

#### 9.6 RocketMQ
与Kafka类似, 区别在于Kafka需要Zookeeper，而RocketMQ则内部集成管理(NameServer)
