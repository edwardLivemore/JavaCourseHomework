### 场景一、医院就医流程: 
1. 患者A先去挂号, 排队等待叫号, 类似于线程要去获取互斥锁, 如果被叫到号, 类似于获取到锁
2. 找大夫B就诊, 但缺乏相应的检测报告, 类似于线程要求的条件没有满足
3. 患者A离开大夫B, 类似于释放互斥锁, 大夫B此时呼叫下一位患者
4. 患者A去其他诊室排队做检测, 类似于进入条件等待队列, 等待检测结果, 类似于等待被唤醒
5. 检测结果出来后, 类似于线程被唤醒, 此时患者A重新到大夫B的诊室前排队, 类似于尝试重新获取互斥锁.

启发：参考就医流程, 当并发量较大时, 线程需要先获取互斥锁, 若执行条件不满足时, 需释放互斥锁, 从而不阻塞其他线程, 
并进入条件等待队列等待被唤醒, 在被唤醒后, 需重新进入之前方法的等待队列, 尝试重新获取互斥锁.

### 场景二、Excel共享协作一:
A、B两人同时写一个Excel, A和B都想将计算结果写入第一行, B先计算出结果, 成功写入第一行, 此时A计算出结果, 
发现第一行已被写入, 于是转而将结果写入第二行, 以此类推, 两人交替写入结果, 直到任务完成.

启发: 并发量不大时, 线程可以通过原子类的CAS操作, 交替执行, 避免由于互斥锁的加锁释放锁导致的性能问题. 

### 场景二、Excel共享协作二:
A、B两人同时写一个Excel, A和B预先沟通号, A写入第一行到第十行的数据, B写入第十一行到二十行的数据, 两人各自计算
并写入自己的数据, 直到任务完成.

启发: 多线程之间可以预先设置好工作区域, 分块执行各自的任务, 知道任务完成. 
参考分库分表以及LongAdder对于AtomicLong的改进.
